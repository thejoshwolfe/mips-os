
.data

headA:	.asciiz "This function computes the Ackerman Function A(m,n)\n"
prmtM:	.asciiz "Enter m: "
prmtN:	.asciiz "Enter n: "

.text
main:
	# print(headA)
	la	$a0,	headA
	jal print_asciiz

	# print(prmtM)
	la	$a0,	prmtM
	jal print_asciiz

	# $s0 = read_int()
	jal read_int
	move	$s0,	$v0

	# print(prmtN)
	la	$a0,	prmtN
	jal print_asciiz

	# $s1 = read_int()
	jal read_int
	move	$s1,	$v0

	# Acker($s0, $s1)
	move	$a0,	$s0
	move	$a1,	$s1
	jal	Acker


	# print_int $v0
	move	$a0,	$v0
	li	$v0,	1
	syscall
	# print_char '\n'
	li	$a0,	10
	li	$v0,	11
	syscall

exit:	li	$v0,	10
	syscall


# int Acker(int m >= 0, int n >= 0)
#  Acker 0 n = n + 1
#  Acker m 0 = Acker(m - 1, 1)
#  Acker m n = Acker(m - 1, Acker(m, n - 1))
Acker:
 A_0_n:
	bne	$a0,	$zero,	mk_stk	# if (m == 0) {
 	# no stack needed
	addi	$v0,	$a1,	1	#   return n + 1
	jr	$ra			# }

 mk_stk: # make stack space
	addi	$sp,	$sp,	-12	# stack[3] = {
	sw	$s0,	8($sp)		#     $s0,
	sw	$s1,	4($sp)		#     &s1,
	sw	$ra,	0($sp)		#     $ra};
	move	$s0,	$a0		# int m;
	move	$s1,	$a1		# int n;

 A_m_0: # //return Acker(m - 1, 1);
	bne	$s1,	$zero,	A_m_n	# if (n == 0) {
	addi	$a0,	$s0,	-1	#   args = {m - 1,
	addi	$a1,	$zero,	1	#           1};
	jal	Acker			#   $v0 = Acker(args);
	j	dl_stk			#   return $v0;
					# }

 A_m_n: # // return Acker(m - 1, Acker(m, n - 1));
	addi	$a1,	$s1,	-1	# args = {m, n - 1};
	jal	Acker			# $v0 = Acker(args);
	addi	$a0,	$s0,	-1	# args = {m - 1,
	move	$a1,	$v0		#         $v0};
	jal	Acker			# $v0 = Acker(args);
					# return $v0;

 dl_stk: # delete stack space
	lw	$s0,	8($sp)		# restore $a0
	lw	$s1,	4($sp)		# restore $s0
	lw	$ra,	0($sp)		# restore $ra
	addi	$sp,	$sp,	12	# free stack

	jr	$ra			# return


print_asciiz:
	# make stack space
	addi	$sp,	$sp,	-8	# stack[2] = {
	sw	$s0,	4($sp)		#     $s0,
	sw	$ra,	0($sp)		#     $ra};
	move	$s0,	$a0		# int cursor;

 print_asciiz__loop:
 	# if ((c = *cursor) == '\0') break;
	lb	$t0,	0($s0)
	beq	$t0,	$zero,	dl_stk
	# print_character(c);
	li	$v0,	11
	move	$a0,	$t0
	syscall
	# cursor++;
	addi $s0, $s0, 1
	j print_asciiz__loop

 print_asciiz__dl_stk:
	# delete stack space
	lw	$s0,	4($sp)		# restore $s0
	lw	$ra,	0($sp)		# restore $ra
	addi	$sp,	$sp,	8	# free stack

	jr	$ra			# return


.data
# allow 20 chars to be read at a time. the bounds are unchecked. oh well.
read_int__buffer: .ascii "01234567890123456789"

.text
read_int:
	# make stack space
	addi $sp, $sp, -8 # stack[2] = {
	sw $s0, 4($sp)    #     $s0,
	sw $ra, 0($sp)    #     $ra};

	# char * end_cursor = buffer;
	la $s0, read_int__buffer

 read_int__read_loop:
	# c = read_character()
	li $v0, 12
	syscall
	move $t0, $v0

	# if (c == '\n') break;
	li $t1, 10
	beq $t0, $t1, read_int__read_break

	# *(end_cursor++) = c;
	sb $t0, 0($s0)
	addi $s0, $s0, 1
	j read_int__read_loop

 read_int__read_break:
 	# end_cursor--;
	addi $s0, $s0, -1

 	# stupid windows line endings.
	# if (*end_cursor == '\r') end_cursor--;
	lb $t0, 0($s0)
	li $t1, 13
	bne $t0, $t1, read_int__after_windows_check
	addi $s0, $s0, -1
 read_int__after_windows_check:

	# int value = 0;
	li $t0, 0
	# char * cursor = buffer;
	la $t1, read_int__buffer
	# int _10 = 10;
	li $t2, 10

 read_int__value_loop:
	# value *= 10
	mult $t0, $t2
	mflo $t0
	mul $t0, $t0, $t2
	# int digit = (*cursor) - '0'
	lb $t4, 0($t1)
	addi $t4, $t4, 48
	# value += digit
	add $t0, $t0, $t4
	# if (cursor == end_cursor) break;
	beq $t1, $s0, read_int__value_break
	# cursor++;
	addi $t1, $t1, 1
	j read_int__value_loop

 read_int__value_break:
	# return value;
	move $v0, $t0
	# delete stack space
	lw $s0, 4($sp)   # restore $s0
	lw $ra, 0($sp)   # restore $ra
	addi $sp, $sp, 8 # free stack
	jr	$ra

